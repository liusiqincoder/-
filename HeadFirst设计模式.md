<ul>重构
    <li>列出需要改变代码的原因
    <li>把问题归零，找出应用中需要变化的代码，把他们独立出来，不要和不需要改变的代码混在一起（设计原则）
    <li>针对接口编程，而不是为了实现编程
    <li>多用组合，少用继承（有一个>是一个）
        </ul>
        
<b>策略模式</b>
    定义了算法族，分别分装起来，让他们可以相互替换，此模式让算法的实现独立于使用算法的用户
    
*观察者模式*
    <li>定义了对象的一对多的依赖，当一个对象状态改变时，他的所有观察者都会收到通知并更新
    为了交互对象松耦合设计而努力
    java内置的观察者模式  继承Observable（是一个类，而非接口，实现有许多问题）
    
    
#  装饰者模式
  <li>（动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案）
    <li>类应该对扩展开放，对修改关闭
    <li>目标是允许类容易扩展，在不修改原有的代码情况下，就可搭配新的行为。
    <li>装饰者和被装饰者有相同的超类型
    <li>可以用一个或多个对象包装一个对象装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，已达到特定的目的
        <b>缺点</b>：常常造成设计中有大量的小类
        
#  工厂方法

    <li>定义了一个创建对象的接口，但由子类决定要实例化的类是哪个，工厂化的方法让类的实例化推迟到子类
    <li>要依赖抽象，不要依赖具体类
    
    
# 抽象工厂方法
    提供一个接口，用于创建相关依赖对象的家族，而不需要明确指明具体类
    工厂方法是创建具体对象，但抽象工厂方法则是对象的组合（组合多个interface）
    
# 单例模式（Singleton）
    确保变量只被实例化一次，并提供一个全局访问点，而且只有用到时才实例化
    但多线程时会出现错误，必须给getInstance()加个双重检查锁
    
    
# 命令模式  
    将请求封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作
    命令模式可以将 动作的请求者 从动作的执行者中解耦
    一般包含以下对象
      client  客户，动作的请求者
      receiver 接收者，命令的执行者   封装具体动作
      command  命令类 <<interface>> 接收执行具体动作的receiver类, 方法： execute()  调用receiver的逻辑动作
      setCommand()  放入动作的请求者中
    还可以在command里添加undo以支持撤销操作
    
    *<h1>空对象  有时不想返回有意义的对象，空对象就很有用</h1>*
    
    用途：命令模式可以用于队列请求，命令将运算打包，交给队列，然后执行程序一个个调用（日程安排，线程池，工作队列）
              and 日志请求  在command新增store()和load()就能支持
              
# 迭代器模式
    定义；提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部的表示
    
   这就使得把遍历的任务交给迭代器，用户不必知道内部实现，达到降低耦合
   
     *单一责任原则   一个类应该只有一个引起变化的原因*
     
     *内聚*
     用来衡量一个类或模块紧密达到单一目的或责任，目标是高内聚
     优点：更容易维护
     缺点：产生大量的类
    
